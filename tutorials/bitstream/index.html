<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/bitstream-hackathon/libs/katex/katex.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/libs/highlight/github.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/css/jtd.css"> <link rel=icon  href="/bitstream-hackathon/assets/favicon.ico"> <title>Stochastic bitstreams 101</title> <div class=page-wrap > <div class=side-bar > <!-- <div class=header > <a href="/bitstream-hackathon/" class=title > <img src="/bitstream-hackathon/assets/pharm_homepage.pdf"> </a> </div> --> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/bitstream-hackathon/" class="menu-list-link ">Home</a> <li class=menu-list-item >Tutorials <ul class=menu-list-child-list  style="display: block;"> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/overview/" class="menu-list-link ">Overview</a> <li class="menu-list-item active"><a href="/bitstream-hackathon/tutorials/bitstream/" class="menu-list-link active">Bitstreams 101</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/pruning/" class="menu-list-link ">Pruning</a> </ul> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <span style="padding-right: 250px;"> <img src="/bitstream-hackathon/assets/red-flush-UWlogo.pdf" width=150px > <img src="/bitstream-hackathon/assets/pharm_homepage.pdf" width=175px  style="padding-bottom: 10px;"> </span> <a id=github  href="/bitstream-hackathon//github.com/UW-PHARM/BitSAD.jl">BitSAD.jl on GitHub</a> </div> <div class=franklin-content ><em>Make sure you have completed the <a href="/bitstream-hackathon/tutorials/overview">getting started</a> tutorial.</em></p> <p><strong>Table of contents:</strong></p> <p><div class=franklin-toc ><ol><li><a href="#basics_of_stochastic_bitstreams">Basics of stochastic bitstreams</a><li><a href="#operations_on_sbitstreams">Operations on <code>SBitstream</code>s</a></ol></div> <h1 id=stochastic_bitstreams_101 ><a href="#stochastic_bitstreams_101" class=header-anchor >Stochastic bitstreams 101</a></h1> <p>A stochastic bitstreams, \(X_t\), is a sequence of samples from a Bernoulli distribution:</p> \[ X_t \sim \mathrm{Ber}(p) \] <p>where \(p\) is the underlying value being encoded. Stochastic bitstreams are the data format used in <a href="https://en.wikipedia.org/wiki/Stochastic_computing">stochastic computing</a>.</p> <p>So, <em>why stochastic bitstreams?</em> You can refer to <a href="http://pages.cpsc.ucalgary.ca/~gaines/reports/COMP/SCS69/SCS69.pdf">Gaines&#39; original work</a> on the topic, but in short, stochastic computing systems tend to be much more area and power efficient compared to traditional binary systems. The reason for this is that any hardware operation on stochastic bitstreams must only process a single bit at a time, and this can often be done in a &quot;streaming&quot; fashion &#40;eliminating the need for sequential logic&#41;.</p> <p>Take multiplication as an example. For numbers represented in floating point binary, multiplication can be an expensive hardware operation. In many ultra-low power systems, floating-point multiplication is evaluated over multiple clock cycles with integer arithemetic units. In contrast, a stochastic computing multiplier is a single AND gate. In the next section, you&#39;ll see why this is the case.</p> <h2 id=basics_of_stochastic_bitstreams ><a href="#basics_of_stochastic_bitstreams" class=header-anchor >Basics of stochastic bitstreams</a></h2> <p>First, let&#39;s try creating a stochastic bitstream.</p> <pre><code class=language-julia >using BitSAD

x &#61; SBitstream&#40;0.3&#41;</code></pre><pre><code class="plaintext code-output">SBitstream{Float64}(value = 0.3)
    with 0 bits.</code></pre> <p>Here, we created a <code>SBitstream</code> &#40;the type in BitSAD for stochastic bitstreams&#41; encoding the real value 0.3. <code>SBitstream</code> will keep track of the mean of the Bernoulli distribution, which we can recover with <code>float</code>.</p> <pre><code class=language-julia >float&#40;x&#41;</code></pre><pre><code class="plaintext code-output">0.3</code></pre>
<p>You&#39;ll also notice that there were &quot;0 bits enqueue&quot; in <code>x</code>. This refers to the fact that the bitstream, <code>x</code>, is a sequence of samples. Currently, we have not drawn any samples from <code>x</code>. We can try that now:</p>
<pre><code class=language-julia >xt &#61; pop&#33;&#40;x&#41;</code></pre><pre><code class="plaintext code-output">SBit(pos = false, neg = false)</code></pre>
<p>Now, we have a single sample, <code>xt</code>, which is of type <code>SBit</code>. An <code>SBit</code> is a &quot;stochastic bit&quot; which is just a convenient alias for a <a href="https://docs.julialang.org/en/v1.6/manual/functions/#Named-Tuples"><code>NamedTuple</code></a> with two parts –- the positive part &#40;<code>pos</code>&#41; and the negative part &#40;<code>neg</code>&#41;.</p>
<blockquote>
<p>Wait, I thought stochastic bitstreams were a single bit sequence? <br />    –- You &#40;probably&#41;</p>
</blockquote>
<p>Yes, in theory, but this definition means that we can only represent real numbers \(p \in [0, 1]\). In practice, we would like to represent signed numbers &#40;though we still normalize them to \(p \in [-1, 1]\)&#41;. BitSAD uses a two-channel format for encoding signed numbers as two underlying bitstreams. One channel is the positive part and the other is the negative part, such that</p>
\[
p = \mathbb{E} \left[ \mathrm{Pos}(X_t) - \mathrm{Neg}(X_t) \right]
\]
<p>Samples from these two separate channels are neatly packaged into a single <code>SBit</code> so that we can think of <code>SBitstream</code>s as a sequence of <code>SBit</code>s without having to worry too much about the underlying signed encoding scheme.</p>
<p>If we want, we can even add <code>SBit</code>s onto a <code>SBitstream</code>.</p>
<pre><code class=language-julia >push&#33;&#40;x, xt&#41;
x</code></pre><pre><code class="plaintext code-output">SBitstream{Float64}(value = 0.3)
    with 1 bits.</code></pre>
<p>We see that <code>x</code> now has a single bit in queue. For convenience, BitSAD provides <code>generate&#33;</code> to pre-load a <code>SBitstream</code> with samples from the underlying distributions.</p>
<pre><code class=language-julia >generate&#33;&#40;x&#41; # add a single sample
@show length&#40;x&#41;
generate&#33;&#40;x, 1000&#41;
x</code></pre><pre><code class="plaintext code-output">length(x) = 2
SBitstream{Float64}(value = 0.3)
    with 1002 bits.</code></pre>
<p>Finally, we can see that the empirical average over the <code>SBit</code>s in queue matches the encoded value quite closely.</p>
<pre><code class=language-julia >abs&#40;estimate&#40;x&#41; - float&#40;x&#41;&#41;</code></pre><pre><code class="plaintext code-output">0.012375249500997998</code></pre>
<h2 id=operations_on_sbitstreams ><a href="#operations_on_sbitstreams" class=header-anchor >Operations on <code>SBitstream</code>s</a></h2>
<p>So far, we have not computed any meaningful results with BitSAD. Let&#39;s go back to the multiplication example and try to multiply two <code>SBitstream</code>s.</p>
<pre><code class=language-julia >y &#61; SBitstream&#40;0.5&#41;
z &#61; x * y</code></pre><pre><code class="plaintext code-output">SBitstream{Float64}(value = 0.15)
    with 0 bits.</code></pre>
<p>The result, <code>z</code>, has an encoded value of <code>0.15 &#61; 0.3 * 0.5</code>. Recall that stochastic bitstreams encode the value in the mean of their underlying distributions. Any function on applied to <code>SBitstream</code>s is implying a function over their means. Thus,</p>
\[
\mathbb{E} [Z_t] = \mathbb{E} [X_t] \mathbb{E} [Y_t]
\]
<p>We can verify this in BitSAD too.</p>
<pre><code class=language-julia >float&#40;z&#41; &#61;&#61; float&#40;x&#41; * float&#40;y&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>So far, we haven&#39;t described how this multiplication is actually executed on hardware. Certainly, multiplying the floating point means then drawing from the resulting distribution would be no better than traditional arithemetic. Stochastic computing takes advantage of the fact that \(X_t\) and \(Y_t\) are independent to note that</p>
\[
\mathbb{E} [Z_t] = \mathbb{E} [X_t] \mathbb{E} [Y_t] = \mathbb{E} [X_t Y_t]
\]
<p>In other words, we can multiply the samples at step <code>t</code> from each sequence to create a new sequence. The mean of this new sequence should match \(\mathbb{E} [Z_t]\). Let&#39;s see it in action.</p>
<pre><code class=language-julia >multiply_sbit&#40;x, y&#41; &#61; SBit&#40;&#40;pos&#40;x&#41; * pos&#40;y&#41;, neg&#40;x&#41; * neg&#40;y&#41;&#41;&#41;

num_samples &#61; 1000
for t in 1:num_samples
    xbit, ybit &#61; pop&#33;&#40;x&#41;, pop&#33;&#40;y&#41;
    zbit &#61; multiply_sbit&#40;xbit, ybit&#41;
    push&#33;&#40;z, zbit&#41;
end

abs&#40;estimate&#40;z&#41; - float&#40;z&#41;&#41;</code></pre><pre><code class="plaintext code-output">0.009999999999999981</code></pre>
<p>We used a helper function, <code>multiply_sbit</code> to multiply the positive and negative channel of each <code>SBit</code> separately. This resulted in a new <code>SBit</code>, <code>zbit</code>, which we pushed onto <code>z</code>. When we take the empirical average of all these <code>zbit</code>s, we see that it is close to the true mean of <code>z</code>.</p>
<p>Hopefully, you can now see why stochastic computing can be so resource efficient. Each channel of <code>multiply_sbit</code> only needed to multiply two 1-bit numbers. This can be done with a single AND gate.</p>


<div class=page-foot >
    <hr>
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> UW-Madison PHARM Group. Last modified: April 07, 2022.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->
    
      <script src="/bitstream-hackathon/libs/katex/katex.min.js"></script>
<script src="/bitstream-hackathon/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
      <script src="/bitstream-hackathon/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>