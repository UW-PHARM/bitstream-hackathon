<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/bitstream-hackathon/libs/katex/katex.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/libs/highlight/github.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/css/jtd.css"> <link rel=icon  href="/bitstream-hackathon/assets/favicon.ico"> <title>Stochastic bitstreams 101</title> <div class=page-wrap > <div class=side-bar > <!-- <div class=header > <a href="/bitstream-hackathon/" class=title > <img src="/bitstream-hackathon/assets/pharm_homepage.jpg"> </a> </div> --> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/bitstream-hackathon/" class="menu-list-link ">Home</a> <li class=menu-list-item >Tutorials <ul class=menu-list-child-list  style="display: block;"> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/overview/" class="menu-list-link ">Overview</a> <li class="menu-list-item active"><a href="/bitstream-hackathon/tutorials/bitstream/" class="menu-list-link active">Bitstreams 101</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/bitstreamlining/" class="menu-list-link ">Bitstreamlining</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/pruning/" class="menu-list-link ">Pruning</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/mobilenet/" class="menu-list-link ">Simulating MobileNet</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/submission/" class="menu-list-link ">Submission guide</a> </ul> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <span style="padding-right: 250px;"> <img src="/bitstream-hackathon/assets/red-flush-UWlogo.jpg" width=150px > <img src="/bitstream-hackathon/assets/pharm_homepage.jpg" width=175px  style="padding-bottom: 10px;"> </span> <a id=github  href="/bitstream-hackathon//github.com/UW-PHARM/BitSAD.jl">BitSAD.jl on GitHub</a> </div> <div class=franklin-content ><em>Make sure you have completed the <a href="/bitstream-hackathon/tutorials/overview">getting started</a> tutorial.</em></p> <p><strong>Table of contents:</strong></p> <p><div class=franklin-toc ><ol><li><a href="#basics_of_stochastic_bitstreams">Basics of stochastic bitstreams</a><li><a href="#operations_on_sbitstreams">Operations on <code>SBitstream</code>s</a></ol></div> <h1 id=stochastic_bitstreams_101 ><a href="#stochastic_bitstreams_101" class=header-anchor >Stochastic bitstreams 101</a></h1> <p>A stochastic bitstreams, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X_t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, is a sequence of samples from a Bernoulli distribution:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>∼</mo><mrow><mi mathvariant=normal >B</mi><mi mathvariant=normal >e</mi><mi mathvariant=normal >r</mi></mrow><mo stretchy=false >(</mo><mi>p</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> X_t \sim \mathrm{Ber}(p) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∼</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathrm">Ber</span></span><span class=mopen >(</span><span class="mord mathnormal">p</span><span class=mclose >)</span></span></span></span></span> <p>where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is the underlying value being encoded. Stochastic bitstreams are the data format used in <a href="https://en.wikipedia.org/wiki/Stochastic_computing">stochastic computing</a>.</p> <p>So, <em>why stochastic bitstreams?</em> You can refer to <a href="http://pages.cpsc.ucalgary.ca/~gaines/reports/COMP/SCS69/SCS69.pdf">Gaines&#39; original work</a> on the topic, but in short, stochastic computing systems tend to be much more area and power efficient compared to traditional binary systems. The reason for this is that any hardware operation on stochastic bitstreams must only process a single bit at a time, and this can often be done in a &quot;streaming&quot; fashion &#40;eliminating the need for sequential logic&#41;.</p> <p>Take multiplication as an example. For numbers represented in floating point binary, multiplication can be an expensive hardware operation. In many ultra-low power systems, floating-point multiplication is evaluated over multiple clock cycles with integer arithemetic units. In contrast, a stochastic computing multiplier is a single AND gate. In the next section, you&#39;ll see why this is the case.</p> <h2 id=basics_of_stochastic_bitstreams ><a href="#basics_of_stochastic_bitstreams" class=header-anchor >Basics of stochastic bitstreams</a></h2> <p>First, let&#39;s try creating a stochastic bitstream.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> BitSAD

x = SBitstream(<span class=hljs-number >0.3</span>)</code></pre><pre><code class="plaintext hljs">SBitstream{Float64}(value = 0.3)
    with 0 bits.</code></pre> <p>Here, we created a <code>SBitstream</code> &#40;the type in BitSAD for stochastic bitstreams&#41; encoding the real value 0.3. <code>SBitstream</code> will keep track of the mean of the Bernoulli distribution, which we can recover with <code>float</code>.</p> <pre><code class="julia hljs">float(x)</code></pre><pre><code class="plaintext hljs">0.3</code></pre>
<p>You&#39;ll also notice that there were &quot;0 bits enqueue&quot; in <code>x</code>. This refers to the fact that the bitstream, <code>x</code>, is a sequence of samples. Currently, we have not drawn any samples from <code>x</code>. We can try that now:</p>
<pre><code class="julia hljs">xt = pop!(x)</code></pre><pre><code class="plaintext hljs">SBit(pos = true, neg = false)</code></pre>
<p>Now, we have a single sample, <code>xt</code>, which is of type <code>SBit</code>. An <code>SBit</code> is a &quot;stochastic bit&quot; which is just a convenient alias for a <a href="https://docs.julialang.org/en/v1.6/manual/functions/#Named-Tuples"><code>NamedTuple</code></a> with two parts –- the positive part &#40;<code>pos</code>&#41; and the negative part &#40;<code>neg</code>&#41;.</p>
<blockquote>
<p>Wait, I thought stochastic bitstreams were a single bit sequence? <br />    –- You &#40;probably&#41;</p>
</blockquote>
<p>Yes, in theory, but this definition means that we can only represent real numbers <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">p \in [0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>. In practice, we would like to represent signed numbers &#40;though we still normalize them to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mo stretchy=false >[</mo><mo>−</mo><mn>1</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">p \in [-1, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >−</span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>&#41;. BitSAD uses a two-channel format for encoding signed numbers as two underlying bitstreams. One channel is the positive part and the other is the negative part, such that</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>p</mi><mo>=</mo><mi mathvariant=double-struck >E</mi><mrow><mo fence=true >[</mo><mrow><mi mathvariant=normal >P</mi><mi mathvariant=normal >o</mi><mi mathvariant=normal >s</mi></mrow><mo stretchy=false >(</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=false >)</mo><mo>−</mo><mrow><mi mathvariant=normal >N</mi><mi mathvariant=normal >e</mi><mi mathvariant=normal >g</mi></mrow><mo stretchy=false >(</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=false >)</mo><mo fence=true >]</mo></mrow></mrow><annotation encoding="application/x-tex">
p = \mathbb{E} \left[ \mathrm{Pos}(X_t) - \mathrm{Neg}(X_t) \right]
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;">[</span><span class=mord ><span class="mord mathrm">Pos</span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord ><span class="mord mathrm" style="margin-right:0.01389em;">Neg</span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span>
<p>Samples from these two separate channels are neatly packaged into a single <code>SBit</code> so that we can think of <code>SBitstream</code>s as a sequence of <code>SBit</code>s without having to worry too much about the underlying signed encoding scheme.</p>
<p>If we want, we can even add <code>SBit</code>s onto a <code>SBitstream</code>.</p>
<pre><code class="julia hljs">push!(x, xt)
x</code></pre><pre><code class="plaintext hljs">SBitstream{Float64}(value = 0.3)
    with 1 bits.</code></pre>
<p>We see that <code>x</code> now has a single bit in queue. For convenience, BitSAD provides <code>generate&#33;</code> to pre-load a <code>SBitstream</code> with samples from the underlying distributions.</p>
<pre><code class="julia hljs">generate!(x) <span class=hljs-comment ># add a single sample</span>
<span class=hljs-meta >@show</span> length(x)
generate!(x, <span class=hljs-number >1000</span>)
x</code></pre><pre><code class="plaintext hljs">length(x) = 2
SBitstream{Float64}(value = 0.3)
    with 1002 bits.</code></pre>
<p>Finally, we can see that the empirical average over the <code>SBit</code>s in queue matches the encoded value quite closely.</p>
<pre><code class="julia hljs">abs(estimate(x) - float(x))</code></pre><pre><code class="plaintext hljs">0.005389221556886259</code></pre>
<h2 id=operations_on_sbitstreams ><a href="#operations_on_sbitstreams" class=header-anchor >Operations on <code>SBitstream</code>s</a></h2>
<p>So far, we have not computed any meaningful results with BitSAD. Let&#39;s go back to the multiplication example and try to multiply two <code>SBitstream</code>s.</p>
<pre><code class="julia hljs">y = SBitstream(<span class=hljs-number >0.5</span>)
z = x * y</code></pre><pre><code class="plaintext hljs">SBitstream{Float64}(value = 0.15)
    with 0 bits.</code></pre>
<p>The result, <code>z</code>, has an encoded value of <code>0.15 &#61; 0.3 * 0.5</code>. Recall that stochastic bitstreams encode the value in the mean of their underlying distributions. Any function on applied to <code>SBitstream</code>s is implying a function over their means. Thus,</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>Z</mi><mi>t</mi></msub><mo stretchy=false >]</mo><mo>=</mo><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=false >]</mo><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">
\mathbb{E} [Z_t] = \mathbb{E} [X_t] \mathbb{E} [Y_t]
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span></span></span></span></span>
<p>We can verify this in BitSAD too.</p>
<pre><code class="julia hljs">float(z) == float(x) * float(y)</code></pre><pre><code class="plaintext hljs">true</code></pre>
<p>So far, we haven&#39;t described how this multiplication is actually executed on hardware. Certainly, multiplying the floating point means then drawing from the resulting distribution would be no better than traditional arithemetic. Stochastic computing takes advantage of the fact that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X_t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">Y_t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are independent to note that</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>Z</mi><mi>t</mi></msub><mo stretchy=false >]</mo><mo>=</mo><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=false >]</mo><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy=false >]</mo><mo>=</mo><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>X</mi><mi>t</mi></msub><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">
\mathbb{E} [Z_t] = \mathbb{E} [X_t] \mathbb{E} [Y_t] = \mathbb{E} [X_t Y_t]
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span></span></span></span></span>
<p>In other words, we can multiply the samples at step <code>t</code> from each sequence to create a new sequence. The mean of this new sequence should match <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=double-struck >E</mi><mo stretchy=false >[</mo><msub><mi>Z</mi><mi>t</mi></msub><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E} [Z_t]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">E</span><span class=mopen >[</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >]</span></span></span></span>. Let&#39;s see it in action.</p>
<pre><code class="julia hljs">multiply_sbit(x, y) = SBit((pos(x) * pos(y), neg(x) * neg(y)))

num_samples = <span class=hljs-number >1000</span>
<span class=hljs-keyword >for</span> t <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:num_samples
    xbit, ybit = pop!(x), pop!(y)
    zbit = multiply_sbit(xbit, ybit)
    push!(z, zbit)
<span class=hljs-keyword >end</span>

abs(estimate(z) - float(z))</code></pre><pre><code class="plaintext hljs">0.0040000000000000036</code></pre>
<p>We used a helper function, <code>multiply_sbit</code> to multiply the positive and negative channel of each <code>SBit</code> separately. This resulted in a new <code>SBit</code>, <code>zbit</code>, which we pushed onto <code>z</code>. When we take the empirical average of all these <code>zbit</code>s, we see that it is close to the true mean of <code>z</code>.</p>
<p>Hopefully, you can now see why stochastic computing can be so resource efficient. Each channel of <code>multiply_sbit</code> only needed to multiply two 1-bit numbers. This can be done with a single AND gate.</p>


<div class=page-foot >
    <hr>
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> UW-Madison PHARM Group. Last modified: October 30, 2023.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->