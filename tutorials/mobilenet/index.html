<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/bitstream-hackathon/libs/katex/katex.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/libs/highlight/github.min.css"> <link rel=stylesheet  href="/bitstream-hackathon/css/jtd.css"> <link rel=icon  href="/bitstream-hackathon/assets/favicon.ico"> <title>Simulating MobileNet</title> <div class=page-wrap > <div class=side-bar > <!-- <div class=header > <a href="/bitstream-hackathon/" class=title > <img src="/bitstream-hackathon/assets/pharm_homepage.jpg"> </a> </div> --> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/bitstream-hackathon/" class="menu-list-link ">Home</a> <li class=menu-list-item >Tutorials <ul class=menu-list-child-list  style="display: block;"> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/overview/" class="menu-list-link ">Overview</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/bitstream/" class="menu-list-link ">Bitstreams 101</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/bitstreamlining/" class="menu-list-link ">Bitstreamlining</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/pruning/" class="menu-list-link ">Pruning</a> <li class="menu-list-item active"><a href="/bitstream-hackathon/tutorials/mobilenet/" class="menu-list-link active">Simulating MobileNet</a> <li class="menu-list-item "><a href="/bitstream-hackathon/tutorials/submission/" class="menu-list-link ">Submission guide</a> </ul> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <span style="padding-right: 250px;"> <img src="/bitstream-hackathon/assets/red-flush-UWlogo.jpg" width=150px > <img src="/bitstream-hackathon/assets/pharm_homepage.jpg" width=175px  style="padding-bottom: 10px;"> </span> <a id=github  href="/bitstream-hackathon//github.com/UW-PHARM/BitSAD.jl">BitSAD.jl on GitHub</a> </div> <div class=franklin-content ><em>Make sure you have completed the <a href="/bitstream-hackathon/tutorials/overview">getting started</a> tutorial.</em></p> <p><strong>Table of contents:</strong></p> <p><div class=franklin-toc ><ol><li><a href="#building_the_bitstream_computing_model">Building the bitstream computing model</a><li><a href="#approximating_the_simulation_error">Approximating the simulation error</a><li><a href="#evaluating_the_baseline_model">Evaluating the baseline model</a><li><a href="#real_simulation">Real simulation</a></ol></div> <h1 id=simulating_mobilenet ><a href="#simulating_mobilenet" class=header-anchor >Simulating MobileNet</a></h1> <h2 id=building_the_bitstream_computing_model ><a href="#building_the_bitstream_computing_model" class=header-anchor >Building the bitstream computing model</a></h2> <p>At the end of <a href="/bitstream-hackathon/tutorials/bitstream">Bitstreams 101</a>, you saw that simulating bitstream computing circuits at the bit level requires generating a bit for each input bitstream, then emulating the hardware on those bits, and pushing the result onto an output bitstream.</p> <p>BitSAD.jl automates this process with a <a href="https://uw-pharm.github.io/BitSAD.jl/dev/docs/tutorials/simulation-and-hardware.html"><code>simulatable</code> function</a> that takes a Julia function and builds a &quot;simulatable&quot; version of it. Unfortunately, we can&#39;t naively apply this function to our model. For example, our model weights and biases are represented as floating point numbers &gt; 1. So, we must first prepare our model for bitstream mode. We have provided you with a utility function that does this step for you.</p> <p>The function is called <code>prepare_bitstream_model</code> and it takes a single argument: the model. It merges the batch norm and convolution layers into a single convolution layer. This is done by adjusting the convolution layer weights and biases according to Eq. 1 below where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> are the original weights and biases, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> are the batch norm scale and shift, and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> are the batch norm running mean and variance.</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mover accent=true ><mi>w</mi><mo>ˉ</mo></mover><mo>=</mo><mfrac><mrow><mi>w</mi><mi>γ</mi></mrow><mi>σ</mi></mfrac><mspace width=2em /><mover accent=true ><mi>b</mi><mo>ˉ</mo></mover><mo>=</mo><mfrac><mrow><mi>γ</mi><mo stretchy=false >(</mo><mi>b</mi><mo>−</mo><mi>μ</mi><mo stretchy=false >)</mo></mrow><mi>σ</mi></mfrac><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex"> \bar{w} = \frac{w \gamma}{\sigma} \qquad \bar{b} = \frac{\gamma (b - \mu)}{\sigma} + \beta </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5678em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.5678em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.1667em;"><span class=mord >ˉ</span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1.7936em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.1076em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:2em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8312em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.25em;"><span class=mord >ˉ</span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:2.113em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.427em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class=mclose >)</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></span> <h2 id=approximating_the_simulation_error ><a href="#approximating_the_simulation_error" class=header-anchor >Approximating the simulation error</a></h2> <p>We see that the total scaling is quite large. This means that we will need long bitstreams to accurately represent the scaled weights and biases. Typically, we would use the <code>simulatable</code> function in BitSAD to empirically measure the effect of this error on our accuracy; however, cycle-accurate simulation of hardware is computationally intensive for a large program like a neural network. At UW-Madison, our group uses the compute resources available on campus to simulate these models. For the hackathon, we will be using an approximation of the error induced by simulating bitstreams.</p> <p>We provide you with a <code>add_conversion_error&#33;</code> function that accepts a model and simulation length in clock cycles. This function will use BitSAD to measure the error incurred by generating bit sequences for each weight and bias, then adjust the floating point weights and biases of the model to be slightly off by the measured error.</p> <p>The accuracy can vary substantially relative to the original baseline accuracy. This can happen if we use an extremely short simulation length or the training regime was not streamlined for bitstream paradigm. In practice, your simulation length should be on the order of 1,000 cycles or more. Your goal in the hackthon is to choose a pruning strategy and requested latency that minimizes energy consumption while maximizing accuracy.</p> <h2 id=evaluating_the_baseline_model ><a href="#evaluating_the_baseline_model" class=header-anchor >Evaluating the baseline model</a></h2> <p>Let us now combine these adjustments and evaluate our model.</p> <p>First, we take a pretrained version of our model, MobileNet v1. In your case, you will prune &#43; finetune this model first, then follow these steps.</p> <pre><code class="julia hljs">include(<span class=hljs-string >&quot;src/setup.jl&quot;</span>);

BSON.<span class=hljs-meta >@load</span> <span class=hljs-string >&quot;src/pretrained.bson&quot;</span> m</code></pre> <p>Let&#39;s see the accuracy of the pretrained model on the provided validation data set.</p> <pre><code class="julia hljs"><span class=hljs-comment >#the simulation length here is 10,000 cycles</span>
evaluate_submission(m, <span class=hljs-number >10</span>,<span class=hljs-number >000</span>)</code></pre> <pre><code class="julia hljs">[ Info: Calculating HW cost...
[ Info: Evaluating simulated model performance...
┌ Info: Evaluation complete!
│
│ Area consumption = <span class=hljs-number >1.2350551110799986e8</span> mm²
│ Energy consumption = <span class=hljs-number >2.338759584800001e9</span> uW * cycles
│ Accuracy = <span class=hljs-number >79.2</span>% correct
│
└ Please submit these results on the website.
(<span class=hljs-number >1.2350551110799986e8</span>, <span class=hljs-number >2.3387595848000012e6</span>, <span class=hljs-number >0.7919858237631863</span>)</code></pre> <p>This accuracy is quite good at 79&#37;&#33;</p> <h2 id=real_simulation ><a href="#real_simulation" class=header-anchor >Real simulation</a></h2> <p>As we mentioned above, simulating the network using BitSAD will be computationally intensive, so we do not require this for the hackathon. Unfortunately, our approximation model does not account for all the possible sources of error in bitstream computing, namely correlations between the input bitstreams as well as errors caused by the stateful emulation of the hardware. BitSAD simulatable functions do account for all these sources of error. If you are interested in evaluating your model using BitSAD, you can execute</p> <pre><code class="julia hljs">mbit = model_scaled |&gt; tosbitstream
msim = make_simulatable(mbit, (<span class=hljs-number >96</span>, <span class=hljs-number >96</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>))</code></pre> <p>This code does two things. First, the <code>tosbitstream</code> function will replace all the array parameters in your model with <code>SBitstream</code> arrays from BitSAD. Next, the <code>make_simulatable</code> function will apply the <code>simulatable</code> function from BitSAD to each layer in the network and wrap the result as a &quot;simulatable&quot; version of the layer. We pass the <code>make_simulatable</code> function the size of our input, since the hardware will be built of a specific size. Finally, you can simulate a single cycle of bitstream execution using</p> <pre><code class="julia hljs">xbit = SBitstream.(x) <span class=hljs-comment ># convert a single input sample to SBitstream</span>
msim(xbit)</code></pre> <p>The output of <code>msim&#40;xbit&#41;</code> will be a single element <code>SBitstream</code> array. If you examine the single element, you will see that it contains a single bit in the queue. That single bit is the result of simulating the bitstream computing hardware. You can now call <code>msim&#40;xbit&#41;</code> repeatedly in a loop to simulate many bit sequentially. For more information, check out the <a href="https://uw-pharm.github.io/BitSAD.jl/dev/README.html">BitSAD.jl docs</a>.</p> <div class=page-foot > <hr> <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> UW-Madison PHARM Group. Last modified: November 11, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> <!-- end of class page-wrap-->